[{"content":"安装gRPC和Protoc 安装protobuf 1 2 3  go get -u google.golang.org/protobuf go get -u google.golang.org/protobuf/proto go get -u google.golang.org/protobuf/protoc-gen-go   安装Protoc 1 2  # 下载二进制文件并添加至环境变量 https://github.com/protocolbuffers/protobuf/releases   安装Protoc插件protoc-gen-go\n1 2  # go install 会自动编译项目并添加至环境变量中 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest   1 2  #protoc-gen-go 文档地址 https://developers.google.com/protocol-buffers/docs/reference/go-generated   创建proto文件并定义服务 新建 task.proto文件 1  touch task.proto   编写task.proto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 指定proto版本 syntax = \u0026#34;proto3\u0026#34;;// 指定包名 package task;// 指定输出 go 语言的源码到哪个目录和 包名 // 主要 目录和包名用 ; 隔开 // 将在当前目录生成 task.pb.go // 也可以只填写 \u0026#34;./\u0026#34;,会生成的包名会变成 \u0026#34;----\u0026#34; option go_package = \u0026#34;./;task\u0026#34;;// 指定RPC的服务名 service TaskService { // 调用 AddTaskCompletion 方法  rpc AddTaskCompletion(request) returns (response);}// RPC TaskService服务,AddTaskCompletion函数的请求参数,即消息 message request { uint32 id = 1;//任务id  string module = 2;//所属模块  int32 value = 3;//此次完成值  string guid = 4;//用户id }// RPC TaskService服务,TaskService函数的返回值,即消息 message response{}  使用Protoc来生成Go代码 1 2 3  protoc --go_out=. --go-grpc_out=. \u0026lt;要进行生成代码的文件\u0026gt;.proto # example protoc --go_out=. --go-grpc_out=. .\\task.proto   这样生成会生成两个.go文件，一个是对应消息task.pb.go，一个对应服务接口task_grpc.pb.go。\n在task_grpc.pb.go中，在我们定义的服务接口中，多增加了一个私有的接口方法： mustEmbedUnimplementedTaskServiceServer()\n使用Go监听gRPC服务端及客户端 监听服务端 并有生成的一个UnimplementedTaskServiceServer结构体来实现了所有的服务接口。因此，在我们自己实现的服务类中，需要继承这个结构体，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 用于实现grpc服务 TaskServiceServer 接口 type TaskServiceImpl struct { // 需要继承结构体 UnimplementedServiceServer 或mustEmbedUnimplementedTaskServiceServer \ttask.mustEmbedUnimplementedTaskServiceServer() } func main() { // 创建Grpc服务 \t// 创建tcp连接 \tlistener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8082\u0026#34;) if err != nil { fmt.Println(err) return } // 创建grpc服务 \tgrpcServer := grpc.NewServer() // 此函数在task.pb.go中,自动生成 \ttask.RegisterTaskServiceServer(grpcServer, \u0026amp;TaskServiceImpl{}) // 在grpc服务上注册反射服务 \treflection.Register(grpcServer) // 启动grpc服务 \terr = grpcServer.Serve(listener) if err != nil { fmt.Println(err) return } } func (s *TaskServiceImpl) AddTaskCompletion(ctx context.Context, in *task.Request) (*task.Response, error) { fmt.Println(\u0026#34;收到一个Grpc 请求, 请求参数为\u0026#34;, in.Guid) r := \u0026amp;task.Response{ } return r, nil }   然后在TaskService上实现我们的服务接口。\n客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  conn, err := grpc.Dial(\u0026#34;127.0.0.1:8082\u0026#34;, grpc.WithInsecure()) if err != nil { panic(err) } defer conn.Close() // 创建grpc客户端 \tclient := task.NewTaskServiceClient(conn) // 创建请求 \treq := \u0026amp;task.Request{ Id: 1, Module: \u0026#34;test\u0026#34;, Value: 3, Guid: \u0026#34;test\u0026#34;, } // 调用rpc TaskService AddTaskCompletion函数 \tresponse, err := client.AddTaskCompletion(context.Background(), req) if err != nil { log.Println(err) return } log.Println(response)   本文参考\n","date":"2022-05-26T14:17:33+08:00","permalink":"https://blog.nmslwsnd.com/p/go-grpc/","title":"Go使用gRPC进行通信"},{"content":"拉取networkboot/dhcpd镜像\n1  docker pull networkboot/dhcpd   新建data/dhcpd.conf文件\n1  touch /data/dhcpd.conf   修改data/dhcpd.conf文件\n1 2 3 4 5 6  subnet 204.254.239.0 netmask 255.255.255.224 { option subnet-mask 255.255.0.0; option domain-name \u0026#34;cname.nmslwsnd.com\u0026#34;; option domain-name-servers 8.8.8.8; range 204.254.239.10 204.254.239.30; }   修改/etc/network/interfaces\n1 2 3 4 5 6 7 8 9  # The loopback network interface (always required) auto lo iface lo inet loopback # Get our IP address from any DHCP server auto dhcp iface dhcp inet static address 204.254.239.0 netmask 255.255.255.224   获取帮助命令\n1  docker run -it --rm networkboot/dhcpd man dhcpd.conf   运行DHCP服务\n1 2 3  docker run -it --rm --init --net host -v \u0026#34;/data\u0026#34;:/data networkboot/dhcpd \u0026lt;网卡名称\u0026gt; # 示例 docker run -it --rm --init --net host -v \u0026#34;/data\u0026#34;:/data networkboot/dhcpd dhcp   ","date":"2022-05-23T11:11:40+08:00","permalink":"https://blog.nmslwsnd.com/p/linux-dhcp/","title":"Linux部署DHCP服务"},{"content":"开始之前 1  import \u0026#34;encoding/xml\u0026#34;   简单的Xml解析 1.假设我们解析的Xml内容如下: 1 2 3  \u0026lt;feed\u0026gt; \u0026lt;person name=\u0026#34;initcool\u0026#34; id=\u0026#34;1\u0026#34; age=18 /\u0026gt; \u0026lt;/feed\u0026gt;   2.接着我们构造对应的结构体 1 2 3 4 5 6 7 8  type Feed struct { XMLName xml.Name `xml:\u0026#34;feed\u0026#34;` Person struct{ Name string `xml:\u0026#34;name\u0026#34;` Id string `xml:\u0026#34;id\u0026#34;` Age int\t`xml:\u0026#34;age\u0026#34;` }\t`xml:\u0026#34;person\u0026#34;` }   3.对Xml数据进行反序列化 1 2 3 4 5 6 7 8 9 10  var feed Feed // 读取Xml文件，并返回字节流 content,err := ioutil.ReadFile(XmlFilename) if err != nil { log.Fatal(err) } // 将读取到的内容反序列化到feed xml.Unmarshal(content,\u0026amp;feed)   带有命名空间的Xml解析 部分xml文件会带有命名空间(Namespace),也就是冒号左侧的内容,此时我们需要在go结构体的tag 中加入命名空间。\n1.带有命名空间(Namespace)的Xml文件 1 2 3 4 5 6  \u0026lt;feed xmlns:yt=\u0026#34;http://www.youtube.com/xml/schemas/2015\u0026#34; xmlns:media=\u0026#34;http://search.yahoo.com/mrss/\u0026#34; xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;!-- yt即是命名空间 --\u0026gt; \u0026lt;yt:videoId\u0026gt;XXXXXXX\u0026lt;/yt:videoId\u0026gt; \u0026lt;!-- media是另一个命名空间 --\u0026gt; \u0026lt;media:community\u0026gt;\u0026lt;/media:community\u0026gt; \u0026lt;/feed\u0026gt;   2.针对命名空间构造结构体 1 2 3 4 5  type Feed struct { XMLName xml.Name `xml:\u0026#34;feed\u0026#34;` // 指定最外层的标签为feed \tVideoId string `xml:\u0026#34;http://www.youtube.com/xml/schemas/2015 videoId\u0026#34;` Community string `xml:\u0026#34;http://search.yahoo.com/mrss/ community\u0026#34;` }   3.对Xml数据进行反序列化 1 2 3 4 5 6 7 8 9 10  var feed Feed // 读取Xml文件，并返回字节流 content,err := ioutil.ReadFile(XmlFilename) if err != nil { log.Fatal(err) } // 将读取到的内容反序列化到feed xml.Unmarshal(content,\u0026amp;feed)   ","date":"2022-05-20T14:38:05+08:00","permalink":"https://blog.nmslwsnd.com/p/go-xml/","title":"Go语言解析Xml"},{"content":"查看Hugo版本号\n1  hugo version   新建一个Hugo页面\n1  hugo new site \u0026lt;siteName\u0026gt;   设置主题\n1 2 3 4 5 6  cd \u0026lt;siteName\u0026gt; git init # 设置为 Stack主题 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack   部署Hugo到github\n","date":"2022-05-20T10:23:53+08:00","permalink":"https://blog.nmslwsnd.com/p/hugo/","title":"Hugo使用指南！"},{"content":"安装Redis Debian下安装Redis服务端 1 2 3 4 5 6  curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs)main\u0026#34; | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis   Windows下安装Redis 第三方GUI客户端 Redis (GUI)管理客户端\n1  winget install qishibo.AnotherRedisDesktopManager   Redis修改监听端口 1  vim /etc/redis/redis.conf   Redis常用命令 bitMap 使用BitMap实现签到,setbit key offset value, key做为时间,offset做为用户id ,value做为签到状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # 示例 setbit key offset value key # 设置用户10086在2022/04/21进行签到 setbit check_in_2022_04_21 10086 1 # 获取用户10086是否在2022/04/21签到 getbit check_in_2022_04_21 10086 # bitcount 获取20220421签到的用户数量  # 可选 start和end参数 # start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位 BITCOUNT 20220421 # BITOP 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上 # operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种： # BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 # BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 # BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 # BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。 # 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。 BITOP AND and-result 20220421 20220420 GETBIT and-result   Redis 消息队列 1 2  # LPUSH key value, Lpush用于生产并添加消息 # LPOP key,用于取出消息   Lrem 1 2 3 4  # count \u0026gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 # count \u0026lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。 # count = 0 : 移除表中所有与 VALUE 相等的值。 LREM key count VALUE   Pipeline Redis 使用的是客户端-服务器（CS）模型和请求/响应协议的 TCP 服务器。这意味着通常情况下一个请求会遵循以下步骤：\n客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。 服务端处理命令，并将结果返回给客户端。 管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline 通过减少客户端与 redis 的通信次数来实现降低往返延时时间，而且 Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。\n通俗点：pipeline就是把一组命令进行打包，然后一次性通过网络发送到Redis。同时将执行的结果批量的返回回来\n1 2 3 4 5 6 7  // 使用 go-redis \tp := Client.Pipeline() for _, v := range val { p.LRem(\u0026#34;user:watched:\u0026#34;+guid, 0, v) } // p.Exec()执行pipeline 请求 \tp.Exec()   本文参考\n","date":"2022-04-21T09:42:24+08:00","permalink":"https://blog.nmslwsnd.com/p/redis/","title":"Redis常用命令"}]