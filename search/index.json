[{"content":"前言 我是一个懒惰的男孩,我甚至懒的不想按键盘上的按键和挪动鼠标.可是我还是想玩游戏,该怎么做呢？\n通过google了解到我可以通过将我自己编写的 dll 文件注入到目标程序内,来实现这个事情.\n将大象放在冰箱里需要几步？\n答案是三步。\nsnes9x 模拟器 Dll 注入实战 一、现在我们需要进行第一步,生成 Dll 文件 准确说是我们需要生成符合 C 标准的 dll 文件,如果你使用 go 语言,直接使用 Cgo 与 C 进行互动,即可生成符合 C 标准的 dll .\n但是很明显,我要用 Rust 来做这件事。\n由于 Rust 拥有出色的所有权机制,和其他语言的交互会导致 Rust 失去这个特性,所以这一块是属于 Unsafe 区域的。\nRust 默认生成的 Dll 是提供给 Rust 语言来调用的,而非C系语言的 dll.\n我们现在来生成 C 系语言的 Dll 吧。\n1.新建项目 lib 目录 lib 目录主要作为库文件以方便其他开发者调用 1 2 3 # 新建库项目 Cargo new --lib \u0026lt;project name\u0026gt; Cargo new --lib joy 2.修改 Cargo.toml 文件 增加 bin 区域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [package] name = \u0026#34;joy\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; [lib] name = \u0026#34;joy\u0026#34; path = \u0026#34;src/lib.rs\u0026#34; crate-type = [\u0026#34;cdylib\u0026#34;] [[bin]] name = \u0026#34;joyrun\u0026#34; path = \u0026#34;src/main.rs\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html 1 2 # 为项目导入依赖ctor来生成符合c标准的dll cargo add ctor 3.修改 lib.rs 使用 ctor 1 2 3 4 5 // lib.rs #[ctor::ctor] fn ctor() { println!(\u0026#34;我是一个dll\u0026#34;) } 4.编译项目生成 joy.dll 以及 joyrun.exe 1 cargo build 现在我们有了我们自己的 dll 文件,该如何将他注入到目标的进程呢？\n二、使用 dll-syringe 进行dll注入 1 cargo add dll-syringe 1.修改main.rs 将刚刚编写的dll注入到目标应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // main.rs use dll_syringe::{Syringe, process::OwnedProcess}; fn main() { // 通过进程名找到目标进程 let target_process = OwnedProcess::find_first_by_name(\u0026#34;snes9x\u0026#34;).unwrap(); // 新建一个注入器 let syringe = Syringe::for_process(target_process); // 将我们刚刚编写的dll加载进去 let injected_payload = syringe.inject(\u0026#34;joy.dll\u0026#34;).unwrap(); // do something else // 将我们刚刚注入的dll从目标程序内移除 syringe.eject(injected_payload).unwrap(); } 2.运行项目 1 2 # 运行项目 cargo run 此时你可能会遇到一个新问题,我的dll已经加载进目标程序了,为什么没有打印 \u0026ldquo;我是一个dll\u0026rdquo;\n3.解决控制台无输出问题 这是由于目标程序没有控制台,所以我们没有看到 dll 的输出,接下来让我们来获取 dll 的输出。\n此时我们可以使用 TCP 交互的方式或采用 OutputDebugStringA function (debugapi.h) 来进行打印\nOutputDebugStringA ,需要额外开启features Win32_System_Diagnostics_Debug\n1 2 3 4 5 6 // Rust Unsafe fn // windows::Win32::System::Diagnostics::Debug::OutputDebugStringA pub unsafe fn OutputDebugStringA\u0026lt;\u0026#39;a, P0\u0026gt;(lpoutputstring: P0) where P0: Into\u0026lt;PCSTR\u0026gt;, // Required features: \u0026#34;Win32_System_Diagnostics_Debug\u0026#34; 采用 Tcp 通信交互\n1 2 // 在lib.rs 新建tcp客户端 let stream = TcpStream::connect(\u0026#34;127.0.0.1:7331\u0026#34;).unwrap(); 1 2 3 4 5 6 7 8 9 10 11 // 在main.rs 新建tcp服务端 let (mut stream, addr) = listener.accept()?; info!(%addr,\u0026#34;Accepted!\u0026#34;); let mut buf = vec![0u8; 1024]; let mut stdout = std::io::stdout(); while let Ok(n) = stream.read(\u0026amp;mut buf[..]) { if n == 0 { break; } stdout.write_all(\u0026amp;buf[..n])? } 1 2 3 # 运行项目 cargo run # 运行之后,大功告成,成功在Tcp服务端看到了,客户端对我们发起了请求。 ","date":"2022-09-17T15:10:26+08:00","permalink":"https://blog.nmslwsnd.com/p/rust-dll/","title":"手把手教你用Rust进行Dll注入"},{"content":" 1 2 # 使用cd 进入到上一个目录 cd - 复制和粘贴\n1 2 ctrl + shift + c ctrl + shift + v 快速移动\n1 2 3 4 # 移动到行首 ctrl + a # 移动到行尾 ctrl + e 快速删除\n1 2 3 4 5 6 # 删除光标之前的内容 ctrl + u # 删除光标之后的内容 ctrl + k # 恢复之前删除的内容 ctrl + y 不适用cat\n1 2 使用less 查看 顶部的文件 less filename 使用alt+backspace删除,以单词为单位\n1 tcpdump host 1.1.1.1 1 2 # 并行执行命令 Parallel find . -type f -name \u0026#39;*.html\u0026#39; -print | parallel gzip ","date":"2022-09-08T15:19:00+08:00","permalink":"https://blog.nmslwsnd.com/p/linux/","title":"Linux"},{"content":"sqlx-cli 创建 migration 1 sqlx migrate add categories 1 2 3 4 5 6 7 -- Add migration script here CREATE TABLE IF NOT EXISTS categories( id INT PRIMARY KEY DEFAULT AUTO_INCREMENT, type_id INT UNIQUE NOT NULL, parent_id INT NOT NULL, name TEXT UNIQUE NOT NULL, ); 运行 migration 1 sqlx migrate run ","date":"2022-08-29T13:55:08+08:00","permalink":"https://blog.nmslwsnd.com/p/rust-sqlx/","title":"Rust Sqlx"},{"content":"Canokeys\n2FA Canokey使用Yubikey Authenticator来进行管理2FA。\n下载Yubikey Authenticator,以下为Yubikey Authenticator官方下载网址\n1 https://www.yubico.com/products/yubico-authenticator/#h-download-yubico-authenticator 运行Yubikey Authenticator\n进入custom reader，在Custom reader fiter处填入 CanoKey\n右上角Add account 增加2FA\n1 2 3 Issuer: 备注 可选 Account name : 用户名 必填项 Secret Key : Hotp或Totp的key 必填项 OpenPGP 安装GPG Windows 用户可下载 Gpg4Win，Linux/macOS 用户使用对应包管理软件安装即可.\n生成主密钥 1 gpg --expert --full-gen-key #生成GPG KEY 推荐使用ECC算法\n1 2 3 4 5 选择(11) ECC (set your own capabilities) # 设置自己的功能 主密钥只保留 Certify 功能，其他功能（Encr,Sign,Auth）使用子密钥 # 子密钥分成三份,分别获得三个不同的功能 # encr 解密功能 # sign 签名功能 # auth 登录验证功能 1 先选择 (S) Toggle the sign capability 1 之后输入q 退出 键入1,选择默认算法\n设置主密钥永不过期\n填写信息,按照实际情况填写即可\n1 Windnows 下会弹出窗口输入密码，注意一定要保管好！！！ 1 2 3 4 5 # 会自动生成吊销证书，注意保存到安全的地方 gpg: AllowSetForegroundWindow(22428) failed: �ܾ����ʡ� gpg: revocation certificate stored as \u0026#39;C:\\\\Users\\\\Andorid\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d\\\\\u0026lt;此处为私钥\u0026gt;.rev\u0026#39; # 以上的REV文件即为吊销证书 public and secret key created and signed. 1 2 3 pub ed25519 2022-01-02 [SC] \u0026lt;此处为Pub\u0026gt; uid \u0026lt;此处为Name\u0026gt; \u0026lt;此处为email\u0026gt; 生成子密钥\n1 gpg --fingerprint --keyid-format long -K 下面生成不同功能的子密钥，其中 \u0026lt;fingerprint\u0026gt; 为上面输出的密钥指纹，本示例中即为 私钥。最后的 2y 为密钥过期时间，可自行设置，如不填写默认永不过期。\n1 2 3 gpg --quick-add-key \u0026lt;fingerprint\u0026gt; cv25519 encr 2y gpg --quick-add-key \u0026lt;fingerprint\u0026gt; ed25519 auth 2y gpg --quick-add-key \u0026lt;fingerprint\u0026gt; ed25519 sign 2y 再次查看目前的私钥，可以看到已经包含了这三个子密钥。\n1 gpg --fingerprint --keyid-format long -K 上面生成了三种功能的子密钥（ssb），分别为加密（E）、认证（A）、签名（S），对应 OpenPGP Applet 中的三个插槽。由于 ECC 实现的原因，加密密钥的算法区别于其他密钥的算法。\n加密密钥用于加密文件和信息。签名密钥主要用于给自己的信息签名，保证这真的是来自我的信息。认证密钥主要用于 SSH 登录。\n备份GPG 1 2 3 4 5 6 7 8 9 # 公钥 gpg -ao public-key.pub --export \u0026lt;ed25519/16位\u0026gt; # 主密钥，请务必保存好！！！ # 注意 key id 后面的 !，表示只导出这一个私钥，若没有的话默认导出全部私钥。 gpg -ao sec-key.asc --export-secret-key \u0026lt;ed25519/16位\u0026gt;! # sign子密钥 gpg -ao sign-key.asc --export-secret-key \u0026lt;ed25519/16位\u0026gt;! gpg -ao auth-key.asc --export-secret-key \u0026lt;ed25519/16位\u0026gt;! gpg -ao encr-key.asc --export-secret-key \u0026lt;ed25519/16位\u0026gt;! 导入Canokey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 查看智能卡设备状态 gpg --card-status # 写入GPG gpg --edit-key \u0026lt;ed25519/16位\u0026gt; # 为上方的sec-key # 选中第一个子密钥 key 1 # 写入到智能卡 keytocard # 再次输入,取消选择 key 1 # 选择第二个子密钥 key 2 keytocard key 2 key 3 keytocard # 保存修改并退出 save #再次查看设备状态,可以看到此时子密钥标识符为 ssb\u0026gt;，表示本地只有一个指向 card-no: F1D0 xxxxxxxx 智能卡的指针，已不存在私钥。现在可以删除掉主密钥了，请再次确认你已安全备份好主密钥。 gpg --card-status 删除本地密钥 1 gpg --delete-secret-keys \u0026lt;ed25519/16位\u0026gt; # 为上方的sec-key 为确保安全，也可直接删除 gpg 的工作目录：%APPDATA%\\gnupg，Linux/macOS: ~/.gunpg。\n使用 Canokey 此时切换回日常使用的环境，首先导入公钥\n1 gpg --import public-key.pub 然后设置子密钥指向 Canokey\n1 2 gpg --edit-card gpg/card\u0026gt; fetch 此时查看本地的私钥，可以看到已经指向了 Canokey\n1 gpg --fingerprint --keyid-format long -K 配置gpg路径\n1 git config --global gpg.program \u0026#34;C:\\Program Files (x86)\\GnuPG\\bin\\gpg.exe\u0026#34; --replace-all Git Commit 签名 首先确保 Git 本地配置以及 GitHub 中的邮箱信息包含在 UID 中，然后设置 Git 来指定使用子密钥中的签名（S）密钥。\n1 git config --global user.signingkey \u0026lt;ed25519/16位\u0026gt; # 为上方的Sign密钥 之后在 git commit 时增加 -S 参数即可使用 gpg 进行签名。也可在配置中设置自动 gpg 签名，此处不建议全局开启该选项，因为有的脚本可能会使用 git am 之类的涉及到 commit 的命令，如果全局开启的话会导致问题。\n1 git config commit.gpgsign true 如果提交到 GitHub，前往 GitHub SSH and GPG keys 添加公钥。此处添加后，可以直接通过对应 GitHub ID 来获取公钥：https://github.com/\u0026lt;yourid\u0026gt;.gpg\nPIV 首先在Web端添加自己的私钥到智能卡，之后前往 WinCrypt SSH Agent 下载并运行，此时查看 ssh-agent 读取到的公钥信息，把输出的公钥信息添加到服务器的 ~/.ssh/authorized_keys\n1 2 3 4 # 设置环境池 $Env:SSH_AUTH_SOCK=\u0026#34;\\\\.\\pipe\\openssh-ssh-agent\u0026#34; # 查看ssh列表 ssh-add -L 此时连接 ssh user@host，会弹出提示输入 PIN 的页面，注意此时输入的是 PIV Applet PIN，输入后即可成功连接服务器。\n1 tips: 可能会出现权限不够的情况,需要禁用Windows服务OpenSSH Authentication Agent 最后可以把该程序快捷方式添加到启动目录 %AppData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup，方便直接使用。\n","date":"2022-08-19T16:42:40+08:00","permalink":"https://blog.nmslwsnd.com/p/canokeys/","title":"Canokey入门指南:2FA、OpenPGP、PIV"},{"content":"开始之前 1 2 3 4 5 6 7 8 9 # 在Cargo.toml 新增以下依赖 [dependencies] serde = { version = \u0026#34;1.0.140\u0026#34;,features = [\u0026#34;derive\u0026#34;] } serde_json = \u0026#34;1.0.82\u0026#34; serde_yaml = \u0026#34;0.8\u0026#34; serde_urlencoded = \u0026#34;0.7.1\u0026#34; # 使用yaserde解析xml yaserde = \u0026#34;0.8.0\u0026#34; yaserde_derive = \u0026#34;0.8.0\u0026#34; Serde通用规则(json,yaml,xml) 1.使用Serde宏通过具体结构实现序列化及反序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 use serde::{Deserialize, Serialize}; // 为结构体实现 Serialize(序列化)属性和Deserialize(反序列化) #[derive(Debug, Serialize, Deserialize, Clone)] pub struct Person { // 将该字段名称修改为lastname #[serde(rename = \u0026#34;lastname\u0026#34;)] name: String, // 反序列化及序列化时忽略该字段(nickname) #[serde(skip)] nickname: String, // 分别设置序列化及反序列化时输出的字段名称 #[serde(rename(serialize = \u0026#34;serialize_id\u0026#34;, deserialize = \u0026#34;derialize_id\u0026#34;)) id: i32, // 为age设置默认值 #[serde(default)] age: i32, } 2.使用serde_json序列化及反序列化 1 2 3 4 5 6 7 8 use serde_json::{json, Value}; let v:serde_json::Value = json!( { \u0026#34;x\u0026#34;:20.0, \u0026#34;y\u0026#34;:15.0 } ); println!(\u0026#34;x:{:#?},y:{:#?}\u0026#34;,v[\u0026#34;x\u0026#34;],v[\u0026#34;y\u0026#34;]); // x:20.0, y:15.0 3.使用Serde宏统一格式化输入、输出字段名称 方法名 方法效果 PascalCase 首字母为大写的驼峰式命名,推荐结构体、枚举等名称以及Yaml配置文件读取使用。 camelCase 首字母为小写的驼峰式命名,推荐Yaml配置文件读取使用。 snake_case 小蛇形命名,用下划线\u0026quot;_\u0026ldquo;连接单词,推荐函数命名以及变量名称使用此种方式。 SCREAMING_SNAKE_CASE 大蛇形命名,单词均为大写形式,用下划线\u0026rdquo;_\u0026ldquo;连接单词。推荐常数及全局变量使用此种方式。 kebab-case(小串烤肉) 同snake_case,使用中横线\u0026rdquo;-\u0026ldquo;替换了下划线\u0026rdquo;_\u0026quot;。 SCREAMING-KEBAB-CAS(大串烤肉) 同SCREAMING_SNAKE_CASE,使用中横线\u0026quot;-\u0026ldquo;替换了下划线\u0026rdquo;_\u0026quot;。 示例:\n1 2 3 4 5 6 7 8 9 10 11 pub struct App { #[serde(rename_all = \u0026#34;PascalCase\u0026#34;)] /// 统一格式化输入、输出字段名称 /// #[serde(rename_all = \u0026#34;camelCase\u0026#34;)] /// #[serde(rename_all = \u0026#34;snake_case\u0026#34;)] /// #[serde(rename_all = \u0026#34;SCREAMING_SNAKE_CASE\u0026#34;)] /// 仅设置 version: String, app_name: String, host: String, } 本文参考:yaserde\n本文参考:magiclen\n","date":"2022-07-25T14:02:22+08:00","permalink":"https://blog.nmslwsnd.com/p/rust-serde/","title":"Rust使用Serde进行序列化及反序列化"},{"content":"安装gRPC和Protoc 安装protobuf 1 2 3 go get -u google.golang.org/protobuf go get -u google.golang.org/protobuf/proto go get -u google.golang.org/protobuf/protoc-gen-go 安装Protoc 1 2 # 下载二进制文件并添加至环境变量 https://github.com/protocolbuffers/protobuf/releases 安装Protoc插件protoc-gen-go\n1 2 # go install 会自动编译项目并添加至环境变量中 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 1 2 #protoc-gen-go 文档地址 https://developers.google.com/protocol-buffers/docs/reference/go-generated 创建proto文件并定义服务 新建 task.proto文件 1 touch task.proto 编写task.proto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 指定proto版本 syntax = \u0026#34;proto3\u0026#34;; // 指定包名 package task; // 指定输出 go 语言的源码到哪个目录和 包名 // 主要 目录和包名用 ; 隔开 // 将在当前目录生成 task.pb.go // 也可以只填写 \u0026#34;./\u0026#34;,会生成的包名会变成 \u0026#34;----\u0026#34; option go_package = \u0026#34;./;task\u0026#34;; // 指定RPC的服务名 service TaskService { // 调用 AddTaskCompletion 方法 rpc AddTaskCompletion(request) returns (response); } // RPC TaskService服务,AddTaskCompletion函数的请求参数,即消息 message request { uint32 id = 1;//任务id string module = 2;//所属模块 int32 value = 3;//此次完成值 string guid = 4;//用户id } // RPC TaskService服务,TaskService函数的返回值,即消息 message response{ } 使用Protoc来生成Go代码 1 2 3 protoc --go_out=. --go-grpc_out=. \u0026lt;要进行生成代码的文件\u0026gt;.proto # example protoc --go_out=. --go-grpc_out=. .\\task.proto 这样生成会生成两个.go文件，一个是对应消息task.pb.go，一个对应服务接口task_grpc.pb.go。\n在task_grpc.pb.go中，在我们定义的服务接口中，多增加了一个私有的接口方法： mustEmbedUnimplementedTaskServiceServer()\n使用Go监听gRPC服务端及客户端 监听服务端 并有生成的一个UnimplementedTaskServiceServer结构体来实现了所有的服务接口。因此，在我们自己实现的服务类中，需要继承这个结构体，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 用于实现grpc服务 TaskServiceServer 接口 type TaskServiceImpl struct { // 需要继承结构体 UnimplementedServiceServer 或mustEmbedUnimplementedTaskServiceServer task.mustEmbedUnimplementedTaskServiceServer() } func main() { // 创建Grpc服务 // 创建tcp连接 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8082\u0026#34;) if err != nil { fmt.Println(err) return } // 创建grpc服务 grpcServer := grpc.NewServer() // 此函数在task.pb.go中,自动生成 task.RegisterTaskServiceServer(grpcServer, \u0026amp;TaskServiceImpl{}) // 在grpc服务上注册反射服务 reflection.Register(grpcServer) // 启动grpc服务 err = grpcServer.Serve(listener) if err != nil { fmt.Println(err) return } } func (s *TaskServiceImpl) AddTaskCompletion(ctx context.Context, in *task.Request) (*task.Response, error) { fmt.Println(\u0026#34;收到一个Grpc 请求, 请求参数为\u0026#34;, in.Guid) r := \u0026amp;task.Response{ } return r, nil } 然后在TaskService上实现我们的服务接口。\n客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 conn, err := grpc.Dial(\u0026#34;127.0.0.1:8082\u0026#34;, grpc.WithInsecure()) if err != nil { panic(err) } defer conn.Close() // 创建grpc客户端 client := task.NewTaskServiceClient(conn) // 创建请求 req := \u0026amp;task.Request{ Id: 1, Module: \u0026#34;test\u0026#34;, Value: 3, Guid: \u0026#34;test\u0026#34;, } // 调用rpc TaskService AddTaskCompletion函数 response, err := client.AddTaskCompletion(context.Background(), req) if err != nil { log.Println(err) return } log.Println(response) 本文参考\n","date":"2022-05-26T14:17:33+08:00","permalink":"https://blog.nmslwsnd.com/p/go-grpc/","title":"Go使用gRPC进行通信"},{"content":"拉取networkboot/dhcpd镜像\n1 docker pull networkboot/dhcpd 新建data/dhcpd.conf文件\n1 touch /data/dhcpd.conf 修改data/dhcpd.conf文件\n1 2 3 4 5 6 subnet 204.254.239.0 netmask 255.255.255.224 { option subnet-mask 255.255.0.0; option domain-name \u0026#34;cname.nmslwsnd.com\u0026#34;; option domain-name-servers 8.8.8.8; range 204.254.239.10 204.254.239.30; } 修改/etc/network/interfaces\n1 2 3 4 5 6 7 8 9 # The loopback network interface (always required) auto lo iface lo inet loopback # Get our IP address from any DHCP server auto dhcp iface dhcp inet static address 204.254.239.0 netmask 255.255.255.224 获取帮助命令\n1 docker run -it --rm networkboot/dhcpd man dhcpd.conf 运行DHCP服务\n1 2 3 docker run -it --rm --init --net host -v \u0026#34;/data\u0026#34;:/data networkboot/dhcpd \u0026lt;网卡名称\u0026gt; # 示例 docker run -it --rm --init --net host -v \u0026#34;/data\u0026#34;:/data networkboot/dhcpd dhcp ","date":"2022-05-23T11:11:40+08:00","permalink":"https://blog.nmslwsnd.com/p/linux-dhcp/","title":"Linux部署DHCP服务"},{"content":"开始之前 1 import \u0026#34;encoding/xml\u0026#34; 简单的Xml解析 1.假设我们解析的Xml内容如下: 1 2 3 \u0026lt;feed\u0026gt; \u0026lt;person name=\u0026#34;initcool\u0026#34; id=\u0026#34;1\u0026#34; age=18 /\u0026gt; \u0026lt;/feed\u0026gt; 2.接着我们构造对应的结构体 1 2 3 4 5 6 7 8 type Feed struct { XMLName xml.Name `xml:\u0026#34;feed\u0026#34;` Person struct{ Name string `xml:\u0026#34;name\u0026#34;` Id string `xml:\u0026#34;id\u0026#34;` Age int\t`xml:\u0026#34;age\u0026#34;` }\t`xml:\u0026#34;person\u0026#34;` } 3.对Xml数据进行反序列化 1 2 3 4 5 6 7 8 9 10 var feed Feed // 读取Xml文件，并返回字节流 content,err := ioutil.ReadFile(XmlFilename) if err != nil { log.Fatal(err) } // 将读取到的内容反序列化到feed xml.Unmarshal(content,\u0026amp;feed) 带有命名空间的Xml解析 部分xml文件会带有命名空间(Namespace),也就是冒号左侧的内容,此时我们需要在go结构体的tag 中加入命名空间。\n1.带有命名空间(Namespace)的Xml文件 1 2 3 4 5 6 \u0026lt;feed xmlns:yt=\u0026#34;http://www.youtube.com/xml/schemas/2015\u0026#34; xmlns:media=\u0026#34;http://search.yahoo.com/mrss/\u0026#34; xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;!-- yt即是命名空间 --\u0026gt; \u0026lt;yt:videoId\u0026gt;XXXXXXX\u0026lt;/yt:videoId\u0026gt; \u0026lt;!-- media是另一个命名空间 --\u0026gt; \u0026lt;media:community\u0026gt;\u0026lt;/media:community\u0026gt; \u0026lt;/feed\u0026gt; 2.针对命名空间构造结构体 1 2 3 4 5 type Feed struct { XMLName xml.Name `xml:\u0026#34;feed\u0026#34;` // 指定最外层的标签为feed VideoId string `xml:\u0026#34;http://www.youtube.com/xml/schemas/2015 videoId\u0026#34;` Community string `xml:\u0026#34;http://search.yahoo.com/mrss/ community\u0026#34;` } 3.对Xml数据进行反序列化 1 2 3 4 5 6 7 8 9 10 var feed Feed // 读取Xml文件，并返回字节流 content,err := ioutil.ReadFile(XmlFilename) if err != nil { log.Fatal(err) } // 将读取到的内容反序列化到feed xml.Unmarshal(content,\u0026amp;feed) ","date":"2022-05-20T14:38:05+08:00","permalink":"https://blog.nmslwsnd.com/p/go-xml/","title":"Go语言解析Xml"},{"content":"查看Hugo版本号\n1 hugo version 新建一个Hugo页面\n1 hugo new site \u0026lt;siteName\u0026gt; 设置主题\n1 2 3 4 5 6 cd \u0026lt;siteName\u0026gt; git init # 设置为 Stack主题 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 部署Hugo到github\n","date":"2022-05-20T10:23:53+08:00","permalink":"https://blog.nmslwsnd.com/p/hugo/","title":"Hugo使用指南！"},{"content":"安装Redis Debian下安装Redis服务端 1 2 3 4 5 6 curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis Windows下安装Redis 第三方GUI客户端 Redis (GUI)管理客户端\n1 winget install qishibo.AnotherRedisDesktopManager Redis修改监听端口 1 vim /etc/redis/redis.conf Redis常用命令 bitMap 使用BitMap实现签到,setbit key offset value, key做为时间,offset做为用户id ,value做为签到状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 示例 setbit key offset value key # 设置用户10086在2022/04/21进行签到 setbit check_in_2022_04_21 10086 1 # 获取用户10086是否在2022/04/21签到 getbit check_in_2022_04_21 10086 # bitcount 获取20220421签到的用户数量 # 可选 start和end参数 # start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位 BITCOUNT 20220421 # BITOP 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上 # operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种： # BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 # BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 # BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 # BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。 # 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。 BITOP AND and-result 20220421 20220420 GETBIT and-result Redis 消息队列 1 2 # LPUSH key value, Lpush用于生产并添加消息 # LPOP key,用于取出消息 Lrem 1 2 3 4 # count \u0026gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 # count \u0026lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。 # count = 0 : 移除表中所有与 VALUE 相等的值。 LREM key count VALUE Pipeline Redis 使用的是客户端-服务器（CS）模型和请求/响应协议的 TCP 服务器。这意味着通常情况下一个请求会遵循以下步骤：\n客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。 服务端处理命令，并将结果返回给客户端。 管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline 通过减少客户端与 redis 的通信次数来实现降低往返延时时间，而且 Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。\n通俗点：pipeline就是把一组命令进行打包，然后一次性通过网络发送到Redis。同时将执行的结果批量的返回回来\n1 2 3 4 5 6 7 // 使用 go-redis p := Client.Pipeline() for _, v := range val { p.LRem(\u0026#34;user:watched:\u0026#34;+guid, 0, v) } // p.Exec()执行pipeline 请求 p.Exec() 本文参考\n","date":"2022-04-21T09:42:24+08:00","permalink":"https://blog.nmslwsnd.com/p/redis/","title":"Redis常用命令"}]